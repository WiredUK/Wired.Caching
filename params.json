{"name":"Wired.Caching","tagline":"A package to simplify caching in your .Net projects","body":"#Wired.Caching#\r\n\r\nThis is a package to simplify caching in your .Net projects. It started as a simple function but has become useful enough for me to drop into a library of it's own. I will likely make a Nuget package of this too at some point.\r\n\r\n##Usage##\r\n\r\n1. Add a reference to this library (duh!) by either:\r\n\r\n    a. Downloading this codebase, or, I recommend;\r\n\r\n    b. Use the [Nuget package](https://www.nuget.org/packages/Wired.Caching) by running this in the package manager console of your project:\r\n\r\n        Install-Package Wired.Caching\r\n\r\n2. Create an instance of the cache service:\r\n\r\n        //This can go anywhere, or preferably be injected\r\n        var cacheService = new InMemoryCache();\r\n\r\n2. Replace code where you need something cached. For example this:\r\n\r\n        var zombies = context.People.Where(p => p.IsDead).ToList();\r\n\r\n    Will become replaced with something like this:\r\n\r\n        var zombies = cacheService.Get(\r\n            \"zombies\",\r\n            () => context.People.Where(p => p.IsDead).ToList(),\r\n            600);\r\n\r\n##Caveat##\r\n\r\nThere's always a [catch](http://shouldiblamecaching.com/) right? The main thing you need to be concerned about is when caching something that uses deferred execution. A database context is a good example here, hence why my example ends with `ToList()`. That materialises the query so you are caching the results and not an `IQueryable` interface. If you forget to do that, you will probably end up with errors telling you that your context has gone away or disconnected.","google":"UA-67803092-1","note":"Don't delete this file! It's used internally to help with page regeneration."}